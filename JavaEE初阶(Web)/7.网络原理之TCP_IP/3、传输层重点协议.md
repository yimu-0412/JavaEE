## 一、UDP 协议

### 1、UDP 协议端格式
![UDP 协议端格式](https://raw.githubusercontent.com/yimu-0412/image/master/image/UDP%20%E5%8D%8F%E8%AE%AE%E7%AB%AF%E6%A0%BC%E5%BC%8F.png)
注：
1. 拼装报头的过程，其实就是所谓的“封装”
2. 16位UDP数据报的长度，表示整个数据报（UDP报头+UDP数据）的最大长度
3. UDP 使用2个字节的数据来表示，单位是字节
4. 2个字节表示范围 0 ~ 65535；一个UDP数据报，最大就是64KB。
5. 使用 UDP 来传输数据，一定要警惕大的报文，如果报文超过64KB，此时可能会丢失一部分数据。
6. 校验和更多的用处，其实就是“证伪”，一旦校验和出错，数据就会直接丢弃。

    1. 校验和具体是如何校验的？
        
        &emsp;&emsp;  实际使用的校验和算法比较多，其中比较常见的，crc，md5···

        &emsp;&emsp;  传输数据地时候，将数据和 crc 校验和一起传输给目标，接受方收到数据和 crc 校验和之后，会验证收到的数据是否正确。具体做法是将数据再进行计算 crc 检验和，如果计算的结果和收到的 crc 检验和结果一致，说明数据传输无误，反之数据传输错误！

        &emsp;&emsp;md5 本质是一个“非对称的哈希算法”，md5 算法本身本质就是针对数据进行一系列的数据变化。

        &emsp;&emsp;md5 算法的特性：

        
            1. 定长：无论输入的字符是多长，得到的md5值都是固定不变的！32位，64位128位····
        
            2. 分散：只要输入的字符串有变化，得到的md5值变化就会很大 

            3. 不可逆：通过原字符串，很容易得到md5；但是通过md5，理论上是无法恢复出原始的字符串！

        &emsp;&emsp;md5 应用场景：
        
            1. 作为 hash 算法（本来职责）；

            2. 作为校验和（很多场景，传输大文件，都会使用 md5 作为校验和）；

            3. 应用于一些密码学的场景

    2. UDP 的校验和是怎样工作的？
### 2、UDP 协议的特点
1. 无连接

    只要知道对方的 IP 和端口号，就直接进行传输，不需要建立连接

2. 不可靠传输

    &emsp;&emsp;没有任何安全机制，发送端发送数据之后，如果因为网络故障或者其他原因无法发到对方，UDP 协议层也不会给应用层返回任何错误信息。

3. 面向数据报

    应用层交给UDP多长的报文，UDP原样发送，既不会拆分，也不会合并。
4. 半双工（只用接收缓冲区，无发送缓冲区）

    &emsp;&emsp;UDP没有真正意义上的 发送缓冲区。发送的数据会直接交给内核，由内核将数据传给网络层协议

    &emsp;&emsp;UDP具有接收缓冲区，但是这个接收缓冲区不能保证收到的UDP报的顺序和发送UDP报的顺序一致；如果缓冲区满了，再到达的UDP数据就会被丢弃；进行后续的传输动作；
5. 大小受限

    &emsp;&emsp;UDP协议首部中有一个16位的最大长度。也就是说一个UDP能传输的数据最大长度是64K（包含UDP首部）。
### 3、基于UDP的应用层协议
1. NFS ：网络文件系统
2. TFTP ：简单的文件传输协议
3. DHCP ：动态主机配置协议
4. BOOTP : 启动协议（用于无盘设备启动）
5. DNS ：域名解析协议 

## 二、TCP 协议 

&emsp;&emsp;TCP,即 Transmission Control Protocol，传输控制协议。对数据传输进行一个详细的控制。

### 1、TCP 协议端格式

&emsp;
![TCP协议端格式](https://raw.githubusercontent.com/yimu-0412/image/master/TCP%E5%8D%8F%E8%AE%AE%E7%AB%AF%E6%A0%BC%E5%BC%8F.png)

1. 源/目的端口:表示数据从哪个进程来，到哪个进程去。
2. 4位TCP报头长度：4个 bit 位，单位是 4个字节，4位首位长度值为1111 =》15，实际的首部长度就是15 * 4 = 60； 
15 * 4 = 60
3. 6位标志位：

    1. URG : 紧急指针是否有效
    2. ACK : 确认号是否有效
    3. PSH : 提示接收端应用程序立刻从 TCP 缓冲区把数据读走
    4. RST : 对方要求重新建立连接，把带有 RST 标识的称为复位报文段
    5. SYN : 请求建立连接，把携带 SYN 标识的称为同步报文段
    6. FIN : 通知对方，本端要关闭了，把携带 FIN 标识的称为结束报文段
4. 16位校验和：发送端填充，CRC 检验。接收端校验不通过，则认为数据有问题。此处的校验和不光包含 TCP 首部，也包含 TCP 数据部分。
5. 16位紧急指针：标识那部分数据是紧急数据。
6. 40字节的头部选项。

### 2、TCP 协议特性

1. 有连接
2. 可靠性传输（可靠性不等于安全性）
3. 面向字节流
4. 全双工

    &emsp;&emsp;创建一个TCP的socket，同时在内核中创建一个**发送缓冲区**和一个**接收缓冲区**；

    1. 调用``write``时，数据会先写入发送缓冲区中；
    2. 如果发送的数据字节数太长，就会拆分成多个 TCP 的数据报发出；
    3. 如果发送的数据字节数太短，就会先在缓冲区等待，等到缓冲区中数据长度合适或者合适实际再发送出去；
    4. 接收数据的时候，数据也是从网卡驱动程序到达内核的接收缓冲区，然后应用程序调用``read``从接收缓冲区拿数据；
    5. 另一方面，TCP的一个连接，既有发送缓冲区，又有接收缓冲区，那么对于一个连接，既可以读数据，又可以写数据。这个概念就叫做**全双工**。
5. 大小不限

    &emsp;&emsp;对于字节流来说，可以简单的理解为，传输数据是基于IO流，流式数据的特征就是在IO流没有关闭的情况下，是无边界的数据，可以多次发送，也可以分开多次接收。

### 3、TCP 原理
&emsp;&emsp;TCP 对数据传输提供的管控机制，主要体现在两个方面：安全和效率。
这些机和线程的设计原则是：保证数据安全的前提下，尽可能提高传输效率。
#### 1.确认应答机制（可靠机制）
&emsp;&emsp;发送方发送给接收方数据之后，接收方就会回应一个应答报文。如果发送方收到这个应答报文，那么就认为接收方已经收到了数据。

&emsp;&emsp;由于网络上的传输，充满不确定性，因此不能通过收到数据的顺序来确定逻辑。因此就需要给应答进行编号。TCP 的序号和确认序号，是以**字节**为单位进行编号的。

![TCP数据序列号](https://raw.githubusercontent.com/yimu-0412/image/master/TCP%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97%E5%8F%B7.png)

&emsp;&emsp;针对每个字节进行编号，依次进行累加。（TCP 序号的起始不一定是从1开始的）

1. **工作过程**：

![TCP 确认应答机制工作过程](https://raw.githubusercontent.com/yimu-0412/image/master/TCP%20%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94%E6%9C%BA%E5%88%B6%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png)

&emsp;&emsp;解释：第一个请求,A 给 B 发送了1000个字节的数据，序号就是1~1000（假设从1开始编号），这就相当于是发送了一个数据报，这个数据报的序号是1，长度为1000；确认应答数据报，里面的确认序号是1001，意思就是1001之前的数据，B 已经收到了。也可以理解成，B 在向 A 索要1001开始的数据。序号1001~2000的数据传输和应答原理与上面的一致。

&emsp;&emsp;TCP 的核心是可靠性，可靠性的核心是确认应答。

2. **其它应用**：生产消费者模型


![生产消费者模型](https://raw.githubusercontent.com/yimu-0412/image/master/%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B.png)

&emsp;&emsp;消息队列负责保存数据，但是消息对列的存储空间不是无限的。所以存的数据就需要定期淘汰。淘汰的原则就是：**如果一个数据没有被消费过，那么就不能被轻易的淘汰！**

&emsp;&emsp;如何判定这个数据是否被消费过？主要就是通过**确认应答**机制。

#### 2.超时重传机制（可靠机制）

&emsp;&emsp;确认应答机制是数据传输比较顺利的情况。但是实际中，数据传输过程中可能会出现丢包的情况。一旦发生数据丢包，就要进入超时传送的机制。
1. 出现数据丢包的原因：

   1. 主机 A 发送数据给B之后，可能因为网络拥堵等原因，数据无法到达主机B；
   2. 主机 A 未收到B 发来的确认应答 

    ![超时重传机制的启动原因](https://raw.githubusercontent.com/yimu-0412/image/master/%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%E7%9A%84%E5%90%AF%E5%8A%A8%E5%8E%9F%E5%9B%A0.png)

2. 解决方法：如果主机A在一个特定时间间隔内没有收到B发来的确认应答，就会进行重发。因此主机 B 会收到很多重复的数据，TCP协议通过数据的序列号就可以达到去重的效果。
3. 超时的时间确定：动态计算这个最大超时时间。

    &emsp;&emsp;Linux 中 以500ms为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。当累积到一定的重传次数，仍然得不到应答，TCP 就会认为网络对端主机出现异常，强制关闭连接。

#### 3.连接管理机制（可靠机制）
&emsp;&emsp;在正常情况下，TCP 要经过三次握手建立连接，四次挥手断开连接。
1. **“三次握手”的过程**
   

![TCP 连接“三次握手”](https://raw.githubusercontent.com/yimu-0412/image/master/image/TCP%20%E8%BF%9E%E6%8E%A5%E2%80%9C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E2%80%9D.png)

&emsp;&emsp;&emsp;&emsp;1. 客户端TCP 向 服务器端TCP 发送 SYN同步报文段（请求），请求建立连接。

&emsp;&emsp;&emsp;&emsp;2. 服务器端TCP 接收到同步报文段之后，就向客户端TCP 发送 SYN应答报文（这个报文的 SYN 和 ACK 都为1）,表示客户端的 SYN 报文已被服务端成功接收了。

&emsp;&emsp;&emsp;&emsp;3. 当客户端收到确认报文之后，继续会向服务器端TCP 返送确认报文段（ACK），确认连接。

&emsp;&emsp;&emsp;&emsp;本应该是“四次握手”，但是中间的 SYN + ACK 可以合在一起（两个操作是同时发生的）。当客户端的 SYN 到达服务器端时，服务器端就会第一时间进行应答 ACK，同时也会第一时间发起 SYN，这两件事情同时触发，故此合成一次传输。

2. 三次握手的目的:
   
   1. 防止重复连接
   
   &emsp;&emsp;&emsp;&emsp;在网络情况比较差或者比较复杂的情况下,发送方可能会连续多次发送建立连接的请求,如果 TCP 只有两次,那么接收方只能选择接收请求或者拒绝请求,但是并不能分辨是正常的请求还是过期请求,如果是过期的请求就会造成错误的连接。

   &emsp;&emsp;&emsp;&emsp;如果 TCP 是三次握手的话，那么客户端在收到服务器端发送的（SYN + ACK）确认报文之后，就会判断当前连接是否为历史连接，如果是历史连接，就会发送终止报文给服务器终止连接；如果是正常连接，就会发送确认报文，进而建立连接。

   1. 同步初始化序列化
   
   &emsp;&emsp;&emsp;&emsp;TCP 为了保证在不稳定的网络环境中构建一个稳定的数据连接，需要一个“序列号”字段来保证自己的稳定性，而这个序列号的作用就是**防止数据包重复发送**，以及有效的解决**数据包接收时顺序颠倒**的问题。

   &emsp;&emsp;&emsp;&emsp;在 TCP 三次握手中的客户端发送给服务器的确认报文之后，就会得到一个可靠的初始化序列号，如果是二次握手，无法进行序列号的确认，进而也就无法得到可靠的序列号了，故此 TCP 连接至少需要三次握手。

3. **“四次挥手的过程”**

![TCP 四次挥手过程](https://raw.githubusercontent.com/yimu-0412/image/master/image/TCP%20%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B.png)

&emsp;&emsp;&emsp;&emsp;中断连接端可以是客户端，也可以是服务器端

&emsp;&emsp;&emsp;&emsp;1. 第一次挥手：客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说"我客户端没有数据要发给你了"，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据

&emsp;&emsp;&emsp;&emsp;2. 第二次挥手：服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。

&emsp;&emsp;&emsp;&emsp;3. 第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。

&emsp;&emsp;&emsp;&emsp;4. 第四次挥手：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了**2MSL**后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。

2. **“四次挥手补充”**

    1. ACK 和 FIN 为什么不能合并发送？

        &emsp;&emsp;服务器收到客户端的 FIN 就会立即触发 ACK，这个操作是由内核完成的。
        &emsp;&emsp;服务器发送的 FIN 是由代码控制的，代码中出现了 ``socket.colse()``这样的操作之后，才会触发 FIN。

    2. CLOSE_WAIT:服务器收到 FIN 之后进入的状态，等待用户代码调用 close，来发送 FIN。
    3. TIME_WAIT：表示客户端收到了 FIN 进入了 TIME_WAIT，这个状态存在的意义主要就是为了处理最后一个 ACK 丢包。即使进程已经退出了，TIME_WAIT 状态仍然会存在（TCP连接不会立即销毁），此状态会等待一定的时间，如果一定的时间没有重传的 FIN 过来，才会真正的销毁。
   
#### 4.滑动窗口（效率机制）
1. **滑动窗口的工作机理**

&emsp;&emsp;TCP 不仅仅是为了保证可靠性，还要尽可能提高传输效率。

![TCP 一发一收传输](https://raw.githubusercontent.com/yimu-0412/image/master/image/TCP%20%E4%B8%80%E5%8F%91%E4%B8%80%E6%94%B6%E4%BC%A0%E8%BE%93.png)

&emsp;&emsp;这种一发一收的过程中，发送方要花费很多时间来等待，性能较差，尤其是在数据往返时间较长的时候。

![TCP 数据传输批量发送](https://raw.githubusercontent.com/yimu-0412/image/master/image/TCP%20%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%89%B9%E9%87%8F%E5%8F%91%E9%80%81.png)

* 窗口大小指的是无需等待确认应答而可以继续发送数据的最大值。窗口越大，效率就越高。图中的窗口大小为4000个字节（四个段）。
* 发送前四个段的时候，不需要等待任何的ACK，直接发送。
* 收到第一个ACK之后，滑动窗口向后移动，继续发送第五个段的数据；以此类推；
* 操作系统为了维护这个滑动窗口，需要开辟**发送缓冲区**来记录当前还有那些数据没有应答；只有应答过的数据，才能从缓冲区删掉。
  
  ![滑动窗口工作过程](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png)

  &emsp;&emsp;当前窗口的范围是1001~5000，也就意味着发送方现在同时发送了1001~2000、2001~3000、3001~4000、4001~5000这四段数据，同时也在等待这四段数据的 ACK；
  &emsp;&emsp;假设2001这个 ACK 先到，发送方就知道1001~2000这段数据已经被对方收到，也就不用再等待这段数据，接下来就会立即再发一个5001~6000的数据，仍然保证窗口大小是四段数据，保证当前同时等待的是四段数据的 ACK。（并不是把四份 ACK 都等到，才发送新数据，而是随着ACK 的收到，就继续往后发送）
  &emsp;&emsp;后发先至的情况？确认序号表示, 从该序号之前，前面的数据都已以收到，例如：如果收到了3001这个 ACK，就表示1001~2000和2001~3000都被对方收到，此时2001这个 ACK 收或者不收，已经不是关键。  

2. **滑动窗口丢包**

    1. **情况一：** 数据报已经抵达，ACK 丢包

![滑动窗口ACK丢失](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3ACK%E4%B8%A2%E5%A4%B1.png)

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;这种情况下，部分ACK丢了并不要紧，因为可以通过后续的ACK进行确认；
 
&emsp;&emsp;&emsp;&emsp;2. **情况二：** 数据包直接丢失
   
   ![滑动窗口数据丢包](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%8C%85.png)

*  当某一段报文段丢失之后，发送端会一直收到 1001 这样的ACK，就像是在提醒发送端 "我想要的是 1001" 一样；
*  如果发送端主机连续三次收到了同样一个 "1001" 这样的应答，就会将对应的数据 1001~2000 重新发送；
*  这个时候接收端收到了 1001 之后，再次返回的ACK就是7001了（因为2001 - 7000）接收端其实之前就已经收到了，被放到了接收端操作系统内核的**接收缓冲区**中；

&emsp;&emsp;这种机制被称为 **"高速重发控制"**（也叫 "快重传"）。

#### 5.流量控制（可靠机制）

&emsp;&emsp;流量控制是对滑动窗口的进一步补充。窗口的大小决定了传输的速率，窗口越大，效率越高；反之，效率就越低。

&emsp;&emsp;接收端处理数据的速度是有限的。如果发送端发的太快，导致接收端的缓冲区被打满，这个时候如果发送端继续发送，就会造成丢包，继而引起丢包重传等等一系列连锁反应。

&emsp;&emsp;但是如何决定窗口的大小呢？此处的流量控制就是**基于接收方的处理能力**来限制窗口的大小。（接收缓冲区空余空间的大小）

**流量控制过程**:

![流量控制过程](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E8%BF%87%E7%A8%8B.png)

* 接收者将自己可以接收的缓冲区大小放入 TCP 首部中的"窗口大小"字段,通过 ACK 通知发送端。比如，当前的接收缓冲区大小是4000，就通过 ACK告诉发送端窗口大小为4000.
* 接收端一旦发现自己的缓冲区快满了，就会将窗口大小设置成一个更小的值通知给发送端；例如：如果接收端接收到1~1000的数据，缓冲区就用了1000，缓冲区大小剩余3000，然后接收端就返回 ACK 告诉发送端缓冲区大小剩余3000。
* 发送方接收到缓冲区大小为3000这个信息，就会减缓发送数据的速率，再次发送数据会以3000作为窗口大小进行发送。
* 如果接收端缓冲区已满，就会将窗口设置为0；这时发送端不再发送数据，但是会定期发送一个窗口探测数据段，这个数据端触发接收端的 ACK，通过ACK 发送端就可以知道当前窗口的大小了。

&emsp;&emsp;接收端如何把窗口大小告诉发送端呢？在TCP首部中，有一个16位窗口字段，就是存放了窗口大小信息；

&emsp;&emsp;16位数字最大表示65535，那么TCP窗口最大就是65535字节么？实际上，TCP首部40字节选项中还包含了一个窗口扩大因子M，实际窗口大小是窗口字段的值**左移M位**；

#### 6.拥塞机制（可靠机制）
&emsp;&emsp;虽然 TCP 的滑动窗口能够高效可靠的发送大量的数据。但是在开始不清楚网络状况的情况下，就贸然发送大量的数据，可能会引发严重的问题。

&emsp;&emsp;鉴于以上问题，TCP 引入了**慢启动**机制，先发送少量的数据，摸清当前的网络情况，如果数据没有发生丢包，就说明网络通畅，可以加大发送速率；如果数据出现丢包，就说明网络拥堵，就降低发送速率。（**通过这样的方式决定发送窗口的大小**）

**拥堵控制过程**：

![拥堵控制过程示意](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E6%8B%A5%E5%A0%B5%E6%8E%A7%E5%88%B6%E8%BF%87%E7%A8%8B%E7%A4%BA%E6%84%8F.png)

* 此处引入一个概念：拥塞窗口。
* 发送开始的时候，定义拥塞窗口为1。
* 每次收到一个 ACK应答，拥塞窗口加1。
* 每次发送数据包的时候，将拥塞窗口和接收端主机犯反馈的窗口作比较，取较小的值作为实际发送的窗口。（**实际窗口=min(流量控制的窗口，拥塞控制的窗口)**）
  
&emsp;&emsp;以上的拥塞窗口的增长速度，是指数级别的。“慢启动”只是指初始时慢，但是增长速度非常快。

![慢启动窗口增长示意图](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E6%85%A2%E5%90%AF%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%A2%9E%E9%95%BF%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

* 为了不增长的那么快，因此不能使拥塞窗口单纯的加倍。
* 此处引入一个叫做慢启动的阈值
* 当拥塞窗口超过这个阈值的时候，不再按照指数方式增长，而是按照线性方式增长
* 当TCP开始启动的时候，慢启动阈值等于窗口最大值
* 在每次超时重发的时候，慢启动阈值会变成原来的一半，同时拥塞窗口置回1

&emsp;&emsp;少量的丢包，我们仅仅是触发超时重传；大量的丢包，我们就认为网络拥塞；

&emsp;&emsp;当TCP通信开始后，网络吞吐量会逐渐上升；随着网络发生拥堵，吞吐量会立刻下降；

&emsp;&emsp;拥塞控制，归根结底是TCP协议想尽可能快的把数据传输给对方，但是又要避免给网络造成太大压力的折中方案。

#### 7.延迟应答（效率机制）

&emsp;&emsp;在保证可靠性的基础上，使得窗口尽可能再大一些。

&emsp;&emsp;如果接收数据的主机立刻返回ACK应答，这时候返回的窗口可能比较小。

* 假设接收端缓冲区为1M，一次收到了500K的数据；如果立刻应答，返回的窗口就是500K；
* 实际上可能处理端的处理速度很快，10ms之内数据就从缓冲区消费掉了。此时接收端处理还远没有达到自己的极限，即使窗口再大一点，也可以处理掉；
* 如果接收端稍微等一会再应答，比如等待200ms再应答，那么此时返回的窗口大小就是1M了。

&emsp;&emsp;所有的包都可以做延时应答吗？肯定不是。

&emsp;&emsp;&emsp;&emsp;1. 数量限制：每隔N个包就应答一次；

&emsp;&emsp;&emsp;&emsp;2.时间限制：超过最大延迟时间就应答一次

&emsp;&emsp;具体的数量和超时时间，依操作系统不同也有差异；一般N取2，超时时间取200ms；

![延时应答例外举例](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E5%BB%B6%E6%97%B6%E5%BA%94%E7%AD%94%E4%BE%8B%E5%A4%96%E4%B8%BE%E4%BE%8B.png)

#### 8.捎带应答（效率机制）

&emsp;&emsp;在延迟应答的基础上，我们发现，很多情况下，客户端服务器在应用层也是 "一发一收" 的。意味着客户端给服务器说了 "How are you"，服务器也会给客户端回一个 "Fine, thank you"；

&emsp;&emsp;那么这个时候ACK就可以搭顺风车，和服务器回应的 "Fine，thank you" 一起回给客户端

![捎带应答](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E6%8D%8E%E5%B8%A6%E5%BA%94%E7%AD%94.png)

### 4、面向字节流：粘包问题

&emsp;&emsp;首先明确的是，粘包问题中的“包”，指的是应用层的数据包。在 TCP 的协议中，没有如同 UDP 一样的“报文长度”的字样，但是有序号这样的一个字段。站在传输层的角度，TCP是一个一个报文过来，按照序号存放在缓冲区中。站在**应用层**的角度，看到的只是**一串连续的字节数据**。应用程序此时无法区分当前缓冲区中有多少个应用层数据报，以及从哪里到哪里是一个完整的应用层数据报。

&emsp;&emsp;如何解决粘包问题呢？**设计一个合理的应用层协议来解决**。

&emsp;&emsp;&emsp;&emsp;1. 给应用层数据设定“结束符”/“分隔符”；

![粘包问题：设定结束符](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%9A%E8%AE%BE%E5%AE%9A%E7%BB%93%E6%9D%9F%E7%AC%A6.png)

&emsp;&emsp;&emsp;&emsp;2. 给应用层数据设定长度

![粘包问题：设定包的长度](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%9A%E8%AE%BE%E5%AE%9A%E5%8C%85%E7%9A%84%E9%95%BF%E5%BA%A6.png)

&emsp;&emsp;粘包问题的核心就是：**明确应用数据包中，包与包的边界**。

### 5、TCP 异常情况
1. 进程终止
   
    &emsp;&emsp;无论进程是如何终止的,本质上都会释放 PCB,也会释放对应的文件描述符,同样触发四次挥手。“进程终止”不代表连接就终止，进程终止相当于调用了``socket.close()``而已。

2. 机器重启
   
   &emsp;&emsp;机器重启也是先关闭进程，仍然是四次挥手。

3. 机器掉电/网线断开

    1. 掉电的是接收方
   
    &emsp;&emsp;接收方掉电时，发送方还在发送数据，此时接收方肯定不会有 ACK，于是就进入超时重传，重传几次之后就会尝试重置连接。如果连接不上，发送方就会放弃连接，然后将连接对应的资源进行回收。

    2. 掉电时发送方

    &emsp;&emsp;接收端认为连接还在，一旦接收端有写入操作，接收端发现连接已经不在了，就会进行reset。即使没有写入操作，TCP自己也内置了一个保活定时器，会定期询问对方是否还在。如果对方不在，也会把连接释放。。
     
### 6、基于 TCP 应用层协议
1. HTTP
2. HTTPS
3. SSH
4. TeInet
5. FTP
6. SMTP
7. 写 TCP 程序时自定义的应用层协议

### 7、面试题

1. 如何基于 UDP 协议实现可靠性传输？（实际考察 TCP）
   
   1. 实现确认应答机制。将每个数据收到之后，都反馈一个ACK（应用程序自己定义一个 ACK 包，反馈回去）；
   2. 实现序号/确认序号，以及实现去重；
   3. 实现超时重传；
   4. 实现连接管理机制；
   5. 提高效率，实现滑动窗口；
   6. 为了限制滑动窗口，实现流量控制和拥塞控制；
   7. 实现延时应答，捎带应答，心跳机制。
   
2. 什么样的场景中适合使用 TCP？什么样的场景适合使用 UDP？

   1. 如果需要可靠性传输，首选 TCP；
   2. 如果传输的单个数据报比较长（超过64K），选用TCP；
   3. 如果特别注重效率，优先 UDP；
   
        &emsp;&emsp;典型场景：机房内部的主机之间通信。

   4. 如果需要广播，优先 UDP；
     
        &emsp;&emsp;一份数据报同时发给多个主机，UDP 本身支持广播。TCP 自身不支持，只能在应用程序中通过多个连接，轮询的方式给每个主机发送数据（伪广播）。

