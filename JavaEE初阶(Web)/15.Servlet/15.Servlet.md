# 一、Servlet

&emsp;&emsp;Servlet 是一种实现动态页面的技术，是一组 Tomcat 提供给程序员的 API，帮助程序员简单高效的开发一个 web app。

## 1、回顾动态页面VS静态页面

&emsp;&emsp;静态页面就是内容始终固定的界面，即使**用户不同/时间不同/输入的参数不同**，页面内容也不会发生变化。

&emsp;&emsp;对应的，动态页面指的是**用户不同/时间不同/输入的参数不同**，页面内容发生变化。

&emsp;举例：
1. 静态页面：Tomcat 的主页面

![静态页面](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2.png)

2. 动态页面：B 站的主页页面

![动态页面](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2.png)

## 2、Servlet 主要做的工作

1. 初始化：允许程序员注册一个类到 Tomcat 中，让这个类和 HTTP 中一个特定的请求相关联（类似于 JS，给按钮关联一个点击事件）。
2. 进入循环（循环中处理很多请求）
   1. 读取 HTTP 请求，Servlet 解析这个请求字符串，生成一个 HttpServletRequest 对象。
   2. 根据请求对象生成一个 HttpServletResponse 对象（表示响应）。根据请求生成对象，这个是初始化阶段注册的类中代码完成的。
   3. 将 HttpServletResponse 对象转换成 HTTP 响应，返回给浏览器。

**注**：程序员**只关注 HttpServletResponse 对象**生成阶段。

# 二、第一个 Servlet 程序

## 1、创建项目
&emsp;&emsp;使用 IDEA 创建一个 Maven 项目。
1. 菜单 -> 文件 -> 新建项目 -> Maven

![创建Servlet项目步骤1](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E5%88%9B%E5%BB%BAServlet%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A41.jpg)

2. 选择项目要存放的目录

![创建Servlet项目步骤2](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E5%88%9B%E5%BB%BAServlet%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A42.jpg)

3. 项目创建完毕后, 一般右下角会弹出以下对话框. 选择 Enable Auto-Import

![创建Servlet项目步骤3](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E5%88%9B%E5%BB%BAServlet%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A43.jpg)

## 2、引入依赖

&emsp;&emsp;Maven 项目创建完成后，会自动生成一个``pom.xml``文件。在此文件中引入 Servlet API 依赖的jar包。
1. 在中央仓库 https://mvnrepository.com/ 中搜索“servlet”，选择“Java Servlet API ”

   ![Maven_Servlet_jar](https://raw.githubusercontent.com/yimu-0412/image/master/image/Maven_Servlet_jar.jpg)

2. 选择版本，一般使用``3.1.0``版本

   ![Servlet 3.1.0版本](https://raw.githubusercontent.com/yimu-0412/image/master/image/Servlet%203.1.0%E7%89%88%E6%9C%AC.jpg)

   &emsp;Servlet 的版本要和 Tomcat 匹配。如果我们使用了 Tomcat8.5 ，那么就使用 Servlet3.1.0。可以在 http://tomcat.apache.org/whichversion.html 查询版本对应关系：

   ![Tomcat-Servlet版本对应](https://raw.githubusercontent.com/yimu-0412/image/master/image/Tomcat-Servlet%E7%89%88%E6%9C%AC%E5%AF%B9%E5%BA%94.png)

3. 把中央仓库中提供的 xml 复制到项目的 pom.xml 中

   ![Java Servlet API-3.1.0中xml](https://raw.githubusercontent.com/yimu-0412/image/master/image/Java%20Servlet%20API-3.1.0%E4%B8%ADxml.jpg)

   &emsp;修改后的 pom.xml 形如：

    ```
    <?xml version="1.0" encoding="UTF-8"?>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>

        <groupId>org.example</groupId>
        <artifactId>day_03</artifactId>
        <version>1.0-SNAPSHOT</version>

        <dependencies>
            <!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api -->
            <dependency>
                <groupId>javax.servlet</groupId>
                <artifactId>javax.servlet-api</artifactId>
                <version>3.1.0</version>
                <scope>provided</scope>
            </dependency>
        </dependencies>

    </project>
    ```
## 3、创建项目

&emsp;&emsp;当项目创建好之后，IDEA 会自动创建一些目录：

&emsp;&emsp;![Maven自动创建目录](https://raw.githubusercontent.com/yimu-0412/image/master/image/Maven%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95.jpg)

&emsp;&emsp;这些目录中：
 
 * src: 表示源代码素所在的位置
 * main/java： 表示源代码的根目录，后续创建的``.java``文件就在这个目录中
 * main/resources：表示项目的一些资源文件所在的目录
 * test/java：表示测试代码的根目录

1. **创建 webapp 目录**

    &emsp;在main目录下，和java目录并列，创建一个webapp目录（注意：不是webapps）

    ![Mawen中创建webapp目录](https://raw.githubusercontent.com/yimu-0412/image/master/image/Mawen%E4%B8%AD%E5%88%9B%E5%BB%BAwebapp%E7%9B%AE%E5%BD%95.jpg)

2.**创建 web.xml** 、

   &emsp;然后在 webapp 目录内部创建一个 WEB-INF 目录，并创建一个 web.xml 文件。

   ![Mawen中创建web.xml文件](https://raw.githubusercontent.com/yimu-0412/image/master/image/Mawen%E4%B8%AD%E5%88%9B%E5%BB%BAweb.xml%E6%96%87%E4%BB%B6.jpg)

3. **编写 web.xml 文件**

    &emsp;web.xml 中拷贝以下代码。
    ```
    <!DOCTYPE web-app PUBLIC
    "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
    "http://java.sun.com/dtd/web-app_2_3.dtd" >

    <web-app>
        <display-name>Archetype Created Web Application</display-name>
    </web-app>
    ```

    &emsp;webapp 目录就是未来部署到 Tomcat 中的一个重要的目录. 当前我们可以往 webapp 中放一些静态资源, 比如 html , css 等。

    &emsp;在这个目录中还有一个重要的文件 web.xml。Tomcat 找到这个文件才能正确处理 webapp 中的动态资源。

4. **编写代码**

    &emsp;在 java 目录中创建一个类 HelloServlet,如下：

    ```
    @WebServlet("/hello")
    public class HelloServlet extends HttpServlet {
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp)
        throws ServletException, IOException {
            System.out.println("hello");
            resp.getWriter().write("hello");
        }
    }
    ```

    * 创建一个类 HelloServlet , 继承自 HttpServlet
    * 在这个类上方加上 @WebServlet("/hello") 注解, 表示Tomcat收到的请求中, 路径为 /hello 的请求才会调用 HelloServlet 这个类的代码。(这个路径未包含 Context Path)
    * 重写``doGet``方法. ``doGet``的参数有两个, 分别表示收到的**HTTP请求**和要构造的**HTTP响应**. 这个方法会在Tomca 收到``GET``请求时触发。
    * ``HttpServletRequest``表示HTTP请求。Tomcat 按照**HTTP请求**的格式把**字符串**格式的请求转成了一个HttpServletRequest对象。后续想获取请求中的信息(方法, url, header, body 等) 都是通过这个对象来获取。
    * ``HttpServletResponse``表示**HTTP响应**。 代码中把响应对象构造好(构造响应的状态码, header,body 等)
    * ``resp.getWriter()``会获取到一个流对象, 通过这个流对象就可以写入一些数据, 写入的数据会被构造成一个 HTTP 响应的 body 部分, Tomcat 会把整个响应转成字符串, 通过 socket 写回给浏览器。




    &emsp;以上代码包含的信息：

    1. 代码不再是通过 ``main`` 方法作为入口，``main`` 已经被包含在 Tomcat 中。
    2. 满足 Tomcat 调用的三个条件
       * 创建的类需要继承自 ``HttpServlet``。
       * 需要使用 ``@WebServlet`` 注解关联上一个HTTP的路径。
       * 需要实现 ``doXXX`` 方法。
  
## 5、打包程序

&emsp;&emsp;使用 maven 进行打包. 打开 maven 窗口 (一般在 IDEA 右侧就可以看到 Maven 窗口, 如果看不到的话可以通过 菜单 -> View -> Tool Window -> Maven 打开)。

&emsp;&emsp;然后展开 Lifecycle , 双击 package 即可进行打包.

![jar包打包](https://raw.githubusercontent.com/yimu-0412/image/master/image/jar%E5%8C%85%E6%89%93%E5%8C%85.jpg)

&emsp;&emsp;如果比较顺利的话, 能够看到 SUCCESS 这样的字样。

![jar包打包成功](https://raw.githubusercontent.com/yimu-0412/image/master/image/jar%E5%8C%85%E6%89%93%E5%8C%85%E6%88%90%E5%8A%9F.jpg)

     如果代码/配置/环境存在问题, 可能会提示 BUILD FAILED, 可以根据具体提示的错误信息具体解决.

&emsp;&emsp;打包成功后, 可以看到在 ``target`` 目录下, 生成了一个 ``jar`` 包。

![jar包显示位置](https://raw.githubusercontent.com/yimu-0412/image/master/image/jar%E5%8C%85%E6%98%BE%E7%A4%BA%E4%BD%8D%E7%BD%AE.jpg)

&emsp;&emsp;以上的``jar``包不是Tomcat需要的，同时这个``jar``包名字太复杂，做以下修改：

1. 在 ``pom.xml`` 中新增一个 ``packing`` 标签, 表示打包的方式是打一个 ``war`` 包。

   ```
   <packaging>war</packaging>
   ```
2. 在 pom.xml 中再新增一个 ``build`` 标签, 内置一个 ``finalName`` 标签, 表示打出的 ``war`` 包的名字 ``HelloServlet``。

   ```
   <build>
      <finalName>ServletHelloWorld</finalName>
   </build>
   ```

&emsp;&emsp;重新使用 maven 打包, 可以看到生成的新的 ``war`` 包的结果。

![修改后war包打包](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E4%BF%AE%E6%94%B9%E5%90%8Ewar%E5%8C%85%E6%89%93%E5%8C%85.jpg)

## 6、部署程序

&emsp;&emsp;把 ``war`` 包拷贝到 Tomcat 的 ``webapps`` 目录下,然后启动 ``Tomcat`` , Tomcat 就会自动把 ``war`` 包解压缩。

![war包自动解压](https://raw.githubusercontent.com/yimu-0412/image/master/image/war%E5%8C%85%E8%87%AA%E5%8A%A8%E8%A7%A3%E5%8E%8B.jpg)

## 7、验证程序

&emsp;&emsp;此时通过浏览器访问 http://127.0.0.1:8080/ServletHelloWorld/hello

![Tomcat 访问结果显示](https://raw.githubusercontent.com/yimu-0412/image/master/image/Tomcat%20%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%9C%E6%98%BE%E7%A4%BA.jpg)

&emsp;&emsp;**注意** ：``URL`` 中的 ``PATH`` 分成两个部分, 其中 ``HelloServlet``` 为 ``Context Path``, ``hello`` 为 ``Servlet Path``。

![URL中Path含义](https://raw.githubusercontent.com/yimu-0412/image/master/image/URL%E4%B8%ADPath%E5%90%AB%E4%B9%89.jpg)

# 三、Smart Tomcat 插件
## 1、安装 Smart Tomcat插件
1. 菜单 -> 文件 -> Settings。

   ![Smart Tomcat插件安装-1](https://raw.githubusercontent.com/yimu-0412/image/master/image/Smart%20Tomcat%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85-1.jpg)

2. 选择 Plugins, 选择 Marketplace, 搜索 "tomcat", 点击 "Install"。

   ![Smart Tomcat插件安装-2](https://raw.githubusercontent.com/yimu-0412/image/master/image/Smart%20Tomcat%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85-2.jpg)

3. 安装完毕之后, 会提示 "重启 IDEA"

   ![Smart Tomcat插件安装-3](https://raw.githubusercontent.com/yimu-0412/image/master/image/Smart%20Tomcat%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85-3.jpg)

## 2、配置 Smart Tomcat插件
1. 点击右上角的 "Edit Configurations···"

   ![配置Smart Tomcat步骤-1](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E9%85%8D%E7%BD%AESmart%20Tomcat%E6%AD%A5%E9%AA%A4-1.png)

2. 点击左侧的"+",选择"Smart Tomcat"

   ![配置Smart Tomcat步骤-2](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E9%85%8D%E7%BD%AESmart%20Tomcat%E6%AD%A5%E9%AA%A4-2.jpg)

3. 在 Name 这一栏填写一个名字(可以随便写),在 Tomcat Server 这一栏选择 Tomcat 所在的目录. 其他的选项不必做出修改。``Context Path``默认填写的值是项目名称。

   ![配置Smart Tomcat步骤-3](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E9%85%8D%E7%BD%AESmart%20Tomcat%E6%AD%A5%E9%AA%A4-3.jpg)

4. 点击 OK 之后, 右上角显示“Smart Tomcat”

   ![配置Smart Tomcat步骤-4](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E9%85%8D%E7%BD%AESmart%20Tomcat%E6%AD%A5%E9%AA%A4-4.jpg)

5. 在浏览器中使用 http://127.0.0.1:8080/day_03/hello 访问页面。

    ![配置Smart Tomcat步骤-5](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E9%85%8D%E7%BD%AESmart%20Tomcat%E6%AD%A5%E9%AA%A4-5.png)

    &emsp;注意路径的对应关系：

    ![Smart Tomcat配置后路径对应关系](https://raw.githubusercontent.com/yimu-0412/image/master/image/Smart%20Tomcat%E9%85%8D%E7%BD%AE%E5%90%8E%E8%B7%AF%E5%BE%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png)

    &emsp;使用 Smart Tomcat 部署的时候, 我们发现 Tomcat 的 webapps 内部并没有被拷贝一个 war 包,也没有看到解压缩的内容.Smart Tomcat 相当于是在 Tomcat 启动的时候直接引用了项目中的 webapp 和 target 目录。

    ![Smart Tomcat启动引入文件](https://raw.githubusercontent.com/yimu-0412/image/master/image/Smart%20Tomcat%E5%90%AF%E5%8A%A8%E5%BC%95%E5%85%A5%E6%96%87%E4%BB%B6.png)

# 四、常见的访问错误总结
## 1、出现 404
&emsp;&emsp;404 代表用户的访问的资源不存在，大概率是 **URL 的路径不正确**。 

1. 少写了 ``ContextPath``，通过 ``/hello`` 访问服务器。

    ![出现404原因](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E5%87%BA%E7%8E%B0404%E5%8E%9F%E5%9B%A0.png)

2. ``Servlet Path`` 输入和 ``URL`` 不匹配、

    &emsp;修改 @WebServlet 注解的路径, ``URL`` 中的路径写作的 ``Servlet Path`` 为“/helloServlet”,两者不匹配。

    ![修改Servlet Path的路径](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E4%BF%AE%E6%94%B9Servlet%20Path%E7%9A%84%E8%B7%AF%E5%BE%84.png)

   ![出现404原因2](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E5%87%BA%E7%8E%B0404%E5%8E%9F%E5%9B%A02.png)

3. 少写 ``Servlet Path``，通过 ``/helloServlet``访问服务器

   ![出现404原因3](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E5%87%BA%E7%8E%B0404%E5%8E%9F%E5%9B%A03.png)

4. web.xml 文件输入错误

    &emsp;清楚 web.xml 的内容

    ![清除web.xml文件](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E6%B8%85%E9%99%A4web.xml%E6%96%87%E4%BB%B6.png)

    &emsp;通过浏览器访问 URL, 可以看到:

    ![出现404原因4](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E5%87%BA%E7%8E%B0404%E5%8E%9F%E5%9B%A04.png)

    &emsp;在 Tomcat 启动的时候也有相关的错误提示：

    ![清除web.xml文件错误信息](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E6%B8%85%E9%99%A4web.xml%E6%96%87%E4%BB%B6%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF.png)

## 2、出现 405

&emsp;&emsp;405 表示对应的 HTTP 请求方法没有实现。最主要的原因是，请求的方法和代码中重写的方法不匹配。

&emsp;&emsp;没有实现 doGet 方法

![出现405错误原因1](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E5%87%BA%E7%8E%B0405%E9%94%99%E8%AF%AF%E5%8E%9F%E5%9B%A01.png)

&emsp;&emsp;继承父类的 doPost 方法
![出现405错误原因2](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E5%87%BA%E7%8E%B0405%E9%94%99%E8%AF%AF%E5%8E%9F%E5%9B%A02.png)

&emsp;&emsp;在浏览器地址栏直接输入 URL , 会发送一个 HTTP GET 请求.此时就会根据 /helloServlet/hello 这个路径找到 HelloServlet 这个类. 并且尝试调用
HelloServlet 的 doGet 方法。但是如果没有实现 ``doGet`` 方法，就会出现如下现象。

![出现405错误提示](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E5%87%BA%E7%8E%B0405%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA.png)

## 3、出现 500

&emsp;&emsp;出现的主要原因是：Servlet 代码中抛出异常代码导致。

&emsp;&emsp;修改代码：

```
@WebServlet("/hello")
public class HelloServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        /*resp.getWriter().write("hello world");*/

        String str = null;
        resp.getWriter().write(str.length());
    }
}   
```
&emsp;&emsp;重启 Tomcat 服务器，重新访问页面, 可以看到:

![出现 500 的提示](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E5%87%BA%E7%8E%B0%20500%20%E7%9A%84%E6%8F%90%E7%A4%BA.png)

&emsp;&emsp;在页面上已经有具体的异常调用栈。

&emsp;&emsp;异常信息里面已经提示了出现异常的代码是 ``HelloServlet.java`` 的第21行。

```
resp.getWriter().write(str.length());
```

## 4、出现“空白页面”

&emsp;&emsp;主要原因就是代码中未输入 ``resp.getWritter().write()`` 操作。

&emsp;&emsp;修改代码：

```
@WebServlet("/hello")
public class HelloServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("hello");
    }
}
```

&emsp;&emsp;重启服务器,访问服务器, 可以看到一个空白页面:

![空白页面](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E7%A9%BA%E7%99%BD%E9%A1%B5%E9%9D%A2.png)

&emsp;&emsp;抓包可以看到, 响应 body 中的内容就是 "空数据"

![抓包空白页面](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E6%8A%93%E5%8C%85%E7%A9%BA%E7%99%BD%E9%A1%B5%E9%9D%A2.png)

## 5、出现“无法访问此网站”、

&emsp;&emsp;一般是 Tomcat 启动就失败了。

&emsp;&emsp;错误实例: Servlet Path 写错了。

![无法访问此网站原因](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E6%AD%A4%E7%BD%91%E7%AB%99%E5%8E%9F%E5%9B%A0.jpg)

&emsp;&emsp;应该写作 "/hello", Tomcat 在启动的时候已经提示了相关的错误。Tomcat 启动的日志里面报错信息可能比较多, 需要耐心观察, 找到关键的提示。

![无法访问此网站错误提示](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E6%AD%A4%E7%BD%91%E7%AB%99%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA.jpg)

![无法访问页面显示](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA.png)

## 6、总结

* 4xx 的状态码表示路径不存在, 往往需要检查 URL 是否正确, 和代码中设定的 Context Path 以及 Servlet Path 是否一致。
* 5xx 的状态码表示服务器出现错误, 往往需要观察页面提示的内容和 Tomcat 自身的日志, 观察是否存在报错。
* 出现连接失败往往意味着 Tomcat 没有正确启动, 也需要观察 Tomcat 的自身日志是否有错误提示。
* 空白页面这种情况则需要我们使用抓包工具来分析 HTTP 请求响应的具体交互过程。

# 五、Servlet 运行原理

## 1、Tomcat 的定位

&emsp;浏览器和 Tomcat 服务器交互的过程：

![浏览器和Tomcat交互过程](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%92%8CTomcat%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B.jpg)

1. 接受请求

   1. 用户在浏览器输入一个 URL，此时浏览器就会构造一个 HTTP 请求。
   2. 这个 HTTP 请求会经过网络协议栈逐层进行封装成二进制的 bit 流，最终通过物理层的硬件设备转换成光信号/电信号传输出去。
   3. 这些承载信息的光信号/电信号通过互联网上的一系列网络设备，最终到达目标主机（这个过程需要网络层和数据链路层参与）
   4. 服务器主机收到这些光信号/电信号，又会通过网络协议栈进行逐层分用，层层解析，最终还原成 HTTP 请求，并将其交给 Tomcat 进程进行处理（根据端口号确定进程）
   5. Tomcat 通过 Socket 读取到这个请求（一个字符串），并按照 HTTP 请求的格式来解析这个请求，根据请求中的 Context Path 确定一个 webapp，再通过 Servlet Path 确定一个具体的类，再根据当前请求的方法（GET/POST/PUT/···），决定调用这个类的 doGet 或者 doPost 方法，此时代码中的 doGet/doPost 方法中第一个参数 HttpServletRequest 就包含了这个 HTTP 请求的详细信息。

2. 根据请求计算响应

   * 在 doGet/doPost 方法中，执行了我们自己的代码，我们的代码会根据请求中的一些信息，来给 HttpServletResponse 对象设置一些属性，例如状态码，header，body等。

3. 返回响应

   1. 当 doGet/doPost 执行完毕后，Tomcat 就会自动把 HttpServletResponse 刚刚设置好的对象装换成一个符合 HTTP 协议的字符串，通过 Socket 把这个响应发送出去。
   2. 此时响应数据在服务器的主机上通过网络协议栈层层封装，最终又得到一个二进制的 bit 流，通过物理层硬件设备转换成光信号/电信号传输出去。
   3. 这些承载光电信号的通过互联网的一些列网络设备，最终到达浏览器所在的主机。
   4. 浏览器主机收到光信号/电信号，又会通过网络协议栈逐层进行分用，层层解析，最终还原成 HTTP 响应，并交给浏览器进行处理。
   5. 浏览器也通过 Socket 读取到这个响应，按照 HTTP 协议的格式解析这个响应，并且把 body 中的数据按照一定的格式显示到浏览器的页面上。

## 2、Tomcat 的伪代码

# 六、Servlet API 详解

## 1、HttpServlet

1. 核心方法

    ![HttpServlet 核心方法](https://raw.githubusercontent.com/yimu-0412/image/master/image/HttpServlet%20%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95.png)

    * Servlet 在开始的时候会调用一次 init 方法，就可以通过自己的 Servlet 类重写 init 方法，然后就可以在初始化阶段做一些其 其他的工作。
    * Servlet 在销毁之前，还会调用一次 destory 方法。程序员可以重写 destory 做一些善后的工作。（destroy方法是有缺陷的，不一定能执行到，如果直接 kill 掉 Tomcat 进程，此时 destroy 方法就来不及执行）
    * 继承 HttpServlet 是为了重写其中的方法，重写的目的就是为了能够把程序员自定义的逻辑插入到 Tomcat 这个“框架”中，然后方便 Tomcat 进行调用。
    * 实际开发的时候主要重写 doXXX 方法, 很少会重写 init / destory / service。
    * Servlet 生命周期：

        ![Servlet 生命周期](https://raw.githubusercontent.com/yimu-0412/image/master/image/Servlet%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png)

    * 注意: HttpServlet 的实例只是在程序启动时创建一次. 而不是每次收到 HTTP 请求都重新创建实例。
    * **经典面试题**：
      * Servlet 在实例化之后调用一次 init 方法。
      * Servlet 每次收到请求，调用一次 service 方法。
      * Servlet 在销毁之前，调用一次 destroy 方法。
  
2. 代码示例
    1. 创建 index.html, 放到 webapp 目录中, 形如:

       ```
       <!DOCTYPE html>
       <html lang="en">
       <head>
         <meta charset="UTF-8">
         <title>Title</title>
       </head>
         <body>
            <button onclick="sendGet()">发送 GET 请求</button>
            <button onclick="sendPost()">发送 POST 请求</button>
            <button onclick="sendPut()">发送 PUT 请求</button>

            <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script>

            <script>
               function sendGet() {
                     $.ajax({
                        type:"get",
                        url:"/day_03/method",
                        success:function(data,status){
                           console.log(data);
                        }
                     })         
               }

               function sendPost(){
                     $.ajax({
                        type:"post",
                        url:"/day_03/method",
                        body:"request body",
                        success:function(data,status){
                           console.log(data);
                        }
                     })
               }


               function sendPut(){
                     $.ajax({
                        type:"put",
                        url:"method",
                        data:"/day_03/request body",
                        success:function (data,statue) {
                           console.log(data);
                        }
                     })
               }
            </script>
         </body>
       </html>
       ```

       ![Webebapp目录（HttpServlet）](https://raw.githubusercontent.com/yimu-0412/image/master/image/Webebapp%E7%9B%AE%E5%BD%95%EF%BC%88HttpServlet%EF%BC%89.png)

     2. 创建 MethodServlet.java。
   
         ```
         @WebServlet("/method")
         public class MethodServlet extends HttpServlet {

            @Override
            protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
               resp.setContentType("text/plain;charset=utf-8");
               resp.getWriter().write("GET 响应");
            }

            @Override
            protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
               resp.setContentType("text/plain;charset=utf-8");
               resp.getWriter().write("POST 响应");
            }

            @Override
            protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
               resp.setContentType("text/plain;charset=utf-8");
               resp.getWriter().write("PUT 响应");
            }
         }
         ```

        ![HttpServlet方法测试](https://raw.githubusercontent.com/yimu-0412/image/master/image/HttpServlet%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95.png)

      3. 关于乱码问题

         &emsp;如果我们在响应在代码中写入中文，例如：

            ```
            resp.getWriter().write("GET 响应");
            resp.getWriter().write("POST 响应");
            resp.getWriter().write("PUT 响应");
            ```
         &emsp;此时在浏览器访问的时候, 会看到 "乱码" 的情况。

         ![HttpServlet乱码问题](https://raw.githubusercontent.com/yimu-0412/image/master/image/HttpServlet%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98.png)

         &emsp;可以在代码中, 通过 resp.setContentType("text/html; charset=utf-8"); 显式的指定编码方式。

         &emsp;此时通过抓包可以看到, 当加上了 resp.setContentType("text/html; charset=utf-8"); 代码之后, 响应中多了 Content-Type 字段, 内部指定了编码方式. 浏览器看到这个字段就能够正确解析中文了。

         ![GET响应的结果](https://raw.githubusercontent.com/yimu-0412/image/master/image/GET%E5%93%8D%E5%BA%94%E7%9A%84%E7%BB%93%E6%9E%9C.jpg)

## 2、HttpServletRequest

1. 核心方法

![HttpServletResquest核心方法](https://raw.githubusercontent.com/yimu-0412/image/master/image/HttpServletResquest%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95.png)

2. 代码示例：打印请求信息、
   ```
   // 将生成的响应的 body 放到 respBody 中
   StringBuilder respBody = new StringBuilder();
   // 打印协议的名称和版本
   respBody.append(req.getProtocol());
   respBody.append("<br>");
   // 打印 HTTP 方法的名称
   respBody.append(req.getMethod());
   respBody.append("<br>");
   // 从协议名称直到 HTTP 请求的第一行的查询字符串地址
   respBody.append(req.getRequestURI());
   respBody.append("<br>");
   // 打印请求上下文的请求 URL 部分
   respBody.append(req.getContextPath());
   respBody.append("<br>");
   // 打印包含在路径后的请求 URL 中的查询字符串
   respBody.append(req.getQueryString());
   resp.getWriter().write(respBody.toString());
   ```
   ![HttpServletResquest方法结果显示](https://raw.githubusercontent.com/yimu-0412/image/master/image/HttpServletResquest%E6%96%B9%E6%B3%95%E7%BB%93%E6%9E%9C%E6%98%BE%E7%A4%BA.png)

3. 获取 GET 请求中的参数
   
   &emsp;&emsp;GET 请求中的参数一般都是通过 query String 传递给服务器。形如：
   ```
   https://v.bitedu.vip/personInf/student?userId=1111&classId=100
   ```
   &emsp;&emsp;此时浏览器通过 query string 给服务器传递了两个参数, userId 和 classId, 值分别是 1111 和 100在服务器端就可以通过 getParameter 来获取到参数的值。

   创建 GetParameter 类
   ```
   @WebServlet("/getParameter")
   public class GetParameter extends HttpServlet {
      @Override
      protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
         resp.setContentType("text/html;charset=utf-8");

         String userId = req.getParameter("userId");
         String classId = req.getParameter("classId");
         resp.getWriter().write("userId: " + userId +
                  "; classId: " + classId );
      }
   }
   ```
   &emsp;&emsp;部署程序，通过 http://localhost:8080/day_03/getParameter 访问，可以看到

   ![获取Get请求中的参数](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E8%8E%B7%E5%8F%96Get%E8%AF%B7%E6%B1%82%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0.png)

   &emsp;&emsp;当没有 query String 的时候，getParameter 获取的值为 null。通过  http://localhost:8080/day_03/getParameter?userId=123&classId=456 访问，可以看到：
   
   ![获取Get请求中的参数1](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E8%8E%B7%E5%8F%96Get%E8%AF%B7%E6%B1%82%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B01.png)
  
   此时说明服务器已经获取到客户端传递过来的参数。

4. 代码示例：获取 POST 请求中的参数（1）

   POST 请求的参数一般通过 body 传递给服务器。body中的数据格式有好多种。如果是采用 form 表单的形式, 仍然可以通过 getParameter 获取参数的值.
   
   1. appication/x-www-form-urlencodeed: **类似于query String 的格式**。
   2. mutlipart/form-data:格式比较复杂，主要用来提交文件的。
   3. application/json：如果 body 是 json 格式，就可以先把整个 body 的字符串都取出来，然后进行解析。使用 ``jackson`` 杰斯
   

   创建 PostParameterServlet 类
   ```
   @WebServlet("/postParameter")
   public class PostParameterServlet extends HttpServlet {

      @Override
      protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
         resp.setContentType("text/html;charset=utf-8");
         String userId = req.getParameter("userId");
         String classId = req.getParameter("classId");
         resp.getWriter().write(String.format("userId: %s;classId: %s <br>",userId,classId));
      }
   }
   ```
   创建 testPost.html 文件，放到 webapp 目录中
   ```
   <!-- 使用 ajax / form 表单来构造 POST 请求  -->
   <form action="postParameter" method="post">
        <input type="text" name="userId">
        <input type="text" name="classId">
        <input type="submit" value="提交">
   </form>
   ```
   部署程序，通过 http://localhost:8080/day_03/testPost.html 访问，可以看到 html

   ![获取Post请求参数1](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E8%8E%B7%E5%8F%96Post%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B01.png)

   在输入框中输入内容, 点击提交

   ![获取Post参数1-1](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E8%8E%B7%E5%8F%96Post%E5%8F%82%E6%95%B01-1.png)

   可以看到跳转到了新的页面, 并显示出了刚刚传入的数据。

   ![获取Post请求参数1-2](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E8%8E%B7%E5%8F%96Post%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B01-2.png)

5. 获取POST 请求中的参数（2）

   如果 POST 请求中的 body 是按照 JSON 的格式来传递, 那么获取参数的代码就要发生调整。

   创建 PostParameterJson1 类
   ```
   @WebServlet("/postJson1")
   public class PostParameterJson1 extends HttpServlet {

      @Override
      protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
         resp.setContentType("application/json;charset=utf-8");
         // 现将整个 body 读取
         String body = readBody(req);
         // 当前的 body 并未解析
         resp.getWriter().write(body);
      }

      private String readBody(HttpServletRequest req) throws IOException {
         // 读取 body 需要根据 req getInputStream 得到一个流对象，从这个流对象中进行读取
         ServletInputStream inputStream = req.getInputStream();

         // 通过 contentLength 拿到请求中的 body 的字节数
         int contentLength = req.getContentLength();
         byte buffer[] = new byte[contentLength];
         inputStream.read(buffer);
         return new String(buffer,"utf-8");
      }
   }
   ```
   创建 testPostJson1.html 

   ```
   <body>
      <button onclick="sendJson()">发送请求</button>

      <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script>

      <script>
         function sendJson(){
               var body={
                  userId: 100,
                  classId: 456
               };

               $.ajax({
                  url: "postJson1",
                  type: "post",
                  contentType:"application/json;charset=utf-8",
                  data:JSON.stringify(body),
                  success:function(body,status){
                     console.log(body);
                  }
               });
         }
      </script>
   </body>
   ```
   在浏览器中通过 http://localhost:8080/day_03/testPostJson1.html 访问，可以看到

   ![获取Post请求参数2](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E8%8E%B7%E5%8F%96Post%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B02.png)

   浏览器就会给服务器发送一个 POST 请求, body 中带有 JSON 格式。
   ```
   POST http://localhost:8080/day_03/postJson1 HTTP/1.1
   Host: localhost:8080
   Connection: keep-alive
   Content-Length: 28
   sec-ch-ua: " Not A;Brand";v="99", "Chromium";v="98", "Microsoft Edge";v="98"
   Accept: */*
   Content-Type: application/json;charset=UTF-8
   X-Requested-With: XMLHttpRequest
   sec-ch-ua-mobile: ?0
   User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.80 Safari/537.36 Edg/98.0.1108.43
   sec-ch-ua-platform: "Windows"
   Origin: http://localhost:8080
   Sec-Fetch-Site: same-origin
   Sec-Fetch-Mode: cors
   Sec-Fetch-Dest: empty
   Referer: http://localhost:8080/day_03/postJson1.html
   Accept-Encoding: gzip, deflate, br
   Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6
   Cookie: Idea-8296e76f=b5903ad5-c679-4771-a266-5c2da89d50d7

   {"userId":100,"classId":456}
   ```
   **注意：**此时服务器拿到的 JSON 数据只是一个整体的 String 类型，如果需要获取到 userId 和 classId 的具体值，就需要搭配 JSON 库进一步解析。

6. 获取 POST 请求中的参数（3）

   引入 jackson 这个库，进行 JSON 的解析。
   
   1. 在 Maven 仓库中搜索 jackson，选择 JackSon Databind

      ![Jackson Databind](https://raw.githubusercontent.com/yimu-0412/image/master/image/Jackson%20Databind.png)

   2. 将 maven 仓库中的依赖配置添加到 pom.xml 

      ```
      <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>2.13.1</version>
        </dependency>
      ```
   3. 创建 PostParameterJson2 类

      ```
      // 创建一个新的类表示 JSON 数据，属性的名字需要和 Json 字符串中的 key 一直
      class JsonData{
         public String userId;
         public String classId;
      }

      @WebServlet("/postJson2")
      public class PostParameterJson2 extends HttpServlet {
         @Override
         protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
            resp.setContentType("application/json;charset=utf-8");
            // 1. 先将请求中的 body 读取
            String body = readBody(req);
            // 2. 创建 ObjectMapper 对象，这个是 jackson 中的核心类
            ObjectMapper objectMapper = new ObjectMapper();
            // 3. 通过 readValue 方法将 body 中的字符串转换成 jsonData 对象
            JsonData1 jsonData1 = objectMapper.readValue(body, JsonData.class);
            resp.getWriter().write("userId: " + jsonData.userId + ", classId:" + jsonData.classId);
         }

         private String readBody(HttpServletRequest req) throws IOException {
            ServletInputStream inputStream = req.getInputStream();
            int contentLength = req.getContentLength();
            byte[] buffer = new byte[contentLength];
            inputStream.read(buffer);
            return new String(buffer,"utf-8");
         }
      }
      ```
   4. 创建 postJson2.html

      ```
      <body>
         <button onclick="sendJson1()">发送请求</button>

         <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script>

         <script>
            function sendJson1(){
                  var body={
                     userId: 123,
                     classId: 456
                  };

                  $.ajax({
                     url: "postJson2",
                     type: "post",
                     contentType:"application/json;charset=utf-8",
                     data:JSON.stringify(body),
                     success:function(body,status){
                        console.log(body);
                     }
                  });
            }
            
         </script>
      </body>
      ```
      通过 http://localhost:8080/day_03/postJson2.html 访问，可以看到

      ![获取Post请求参数3](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E8%8E%B7%E5%8F%96Post%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B03.png)

   5. 过程解析

      ```
      ObjectMapper objectMapper = new ObjectMapper();
      JsonData jsonData = objectMapper.readValue(body, JsonData.class);
      ```
      上述代码的第二行就完成了 JSON 格式字符串到 Java 对象的解析过程。
      
      * JsonData.class 的作用：body 的值 {“userId”：123，“classId”：456}
       
         1. 先将 JSON 格式的字符串转换成类似于 HashMap 的键值对结构

            ```
            userId=123&classId=456;
            ```
         2. 根据类对象，获取到要转换结果的类，都有那些属性，每个属性的名字是什么，此处就通过 JsonData 获取到，里面的属性有两个，名字是 userId 和 classId[通过反射机制]
         3. 拿着 JsonData 里面每个属性的名字，去第一步构造的哈希表中查询，如果查询到，就把查询的值赋值到 JsonData 对应的属性里面。

7. 小结
  
   结合以上的案例，主要演示了 HttpServletRequest 类的基本用法。结合 Http 协议的格式，理解 HttpServletRequest 中提供的方法。

   平时 HttpServletRequest 最常用的工作就是，就是获取请求中的参数

      1. 通过 query String ，使用 getParameter 方法。
      2. 通过 body（application/x-www-form-urlencoded）,使用 getParameter 方法。
      3. 通过 body（application/json），先把整个 body 读取，然后使用 json 库进行解析。

## 3、HttpServletResponse

&emsp;&emsp;Servlet 中的 doXXX 方法的目的就是根据请求计算得到相应, 然后把响应的数据设置到 HttpServletResponse 对象中。

&emsp;&emsp;然后 Tomcat 就会把这个 HttpServletResponse 对象按照 HTTP 协议的格式, 转成一个字符串, 并通过 Socket 写回给浏览器。 

1. **核心方法**

   ![HttpServletResponse核心方法](https://raw.githubusercontent.com/yimu-0412/image/master/image/HttpServletResponse%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95.png)

   注意：响应对象是服务器要返回给浏览器的内容，这里面的重要信息都是程序员自定义的，因此上面的方法都是“写”方法。

   注意：对于状态码/响应头的设置要放到 getWriter/getOutputStream 之前，否则可能设置失效。

2. **代码示例**
   1. **设置状态码**
   
      实现一个程序，用户在浏览器通过参数指定返回响应的状态码。

      创建 StatusServlet 类
      ```
      @WebServlet("/status")
      public class StatusServlet extends HttpServlet {
         @Override
         protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

            resp.setContentType("text/html;charset=utf-8");
            // 让用户传入一个请求
            // 请求在 query String 带一个参数，就表示响应的状态码
            // 然后根据用户的输入，返回不同的状态码的响应
            String statusString = req.getParameter("status");
            if(statusString == null || statusString == ""){
                  resp.getWriter().write("当前的请求参数 status  缺失");
                  return;
            }
            resp.setStatus(Integer.parseInt(statusString));
            resp.getWriter().write("status： " + statusString);
         }
      }
      ```
      部署程序，在浏览器中通过 http://localhost:8080/day_03/status?status=404 访问，可以看到

      ![设置响应状态码](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E8%AE%BE%E7%BD%AE%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81.png)

      抓包结果：

      ```
      HTTP/1.1 404
      Content-Type: text/html;charset=utf-8
      Content-Length: 13
      Date: Wed, 09 Feb 2022 08:36:45 GMT
      Keep-Alive: timeout=20
      Connection: keep-alive

      status： 404
      ```
      变换不同的 status 值，就可以看到不同的响应结果。
   
   2. **自动刷新**

      实现一个程序，让浏览器每秒钟自动刷新一次。

      创建 AutoRefreshServlet 类。
      ```
      @WebServlet("/refresh")
      public class AutoRefreshServlet extends HttpServlet {
         @Override
         protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
            resp.setContentType("text/html;charset=utf-8");
            resp.setHeader("Refresh","1");
            
            // long timeStamp = System.currentTimeMillis();
            long timeStamp = new Date().getTime();
            resp.getWriter().write("timeStamp: " + timeStamp);

         }
      }
      ```

      * 通过 HTTP 响应报头中的 Refresh 字段, 可以控制浏览器自动刷新的时机。
      * 通过 Date 类的 getTime 方法可以获取到当前时刻的毫秒级时间戳。
      
      部署程序，通过 http://localhost:8080/day_05/refresh 进行访问，可以看到浏览器每秒钟自动刷新一次。

      ![响应的自动刷新](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E5%93%8D%E5%BA%94%E7%9A%84%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0.png)

      抓包结果：
      ```
      HTTP/1.1 200
      Refresh: 1
      Content-Type: text/html;charset=utf-8
      Content-Length: 24
      Date: Wed, 09 Feb 2022 13:34:22 GMT
      Keep-Alive: timeout=20
      Connection: keep-alive

      timeStamp: 1644413662464
      ```
   3. 重定向
     
      实现一个程序，返回一个重定向 HTTP 响应，自定跳转到另一个页面

      创建 RedirectServlet 类
      ```
      @WebServlet("/redirect")
      public class RedirectServlet extends HttpServlet {
         @Override
         protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

            // 用户访问这个路径的时候，直接重定向到搜狗主页
            /*resp.setStatus(302);
            resp.setHeader("Location","https://www.sogou.com");*/

            resp.sendRedirect("https://www.sogou.com");
         }
      }
      ```
      部署程序，通过 http://localhost:8080/day_05/redirect 访问，可以看到页面自动跳转到搜狗主页了。

      抓包结果

       ![重定向抓包页面](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E9%87%8D%E5%AE%9A%E5%90%91%E6%8A%93%E5%8C%85%E9%A1%B5%E9%9D%A2.png)

      ```
      HTTP/1.1 302
      Location: https://www.sogou.com
      Content-Length: 0
      Date: Wed, 09 Feb 2022 13:47:07 GMT
      Keep-Alive: timeout=20
      Connection: keep-alive
      ```
   4. 服务器版表白墙

      1. 准备工作

         1. 创建 maven 项目
         2. 创建必要的目录 webapp,WEN-INF,web.xml
            ```
            <!DOCTYPE web-app PUBLIC
            "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
            "http://java.sun.com/dtd/web-app_2_3.dtd" >
            <web-app>
            <display-name>Archetype Created Web Application</display-name>
            </web-app><!DOCTYPE web-app PUBLIC
            "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
            "http://java.sun.com/dtd/web-app_2_3.dtd" >
            <web-app>
            <display-name>Archetype Created Web Application</display-name>
            </web-app>
            ```
         3. 调整 pom.xml

            引入依赖, 配置生成 war 包, 以及 war 包名字
            ```
            <?xml version="1.0" encoding="UTF-8"?>
            <project xmlns="http://maven.apache.org/POM/4.0.0"
                     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                     xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
               <modelVersion>4.0.0</modelVersion>

               <groupId>org.example</groupId>
               <artifactId>messagewall</artifactId>
               <version>1.0-SNAPSHOT</version>
               
               <build>
                  <plugins>
                        <plugin>
                           <groupId>org.apache.maven.plugins</groupId>
                           <artifactId>maven-compiler-plugin</artifactId>
                           <configuration>
                              <source>7</source>
                              <target>7</target>
                           </configuration>
                        </plugin>
                  </plugins>
               </build>

               <dependencies>
                  <dependency>
                        <groupId>javax.servlet</groupId>
                        <artifactId>javax.servlet-api</artifactId>
                        <version>3.1.0</version>
                  </dependency>

                  <dependency>
                        <groupId>com.fasterxml.jackson.core</groupId>
                        <artifactId>jackson-databind</artifactId>
                        <version>2.13.1</version>
                  </dependency>

                  <dependency>
                        <groupId>mysql</groupId>
                        <artifactId>mysql-connector-java</artifactId>
                        <version>8.0.27</version>
                  </dependency>
               </dependencies>

            </project>
            ```
         4. 把之前实现的表白墙前端页面拷贝到 webapp 目录中。

            ![表白墙放入 webapp 目录](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E8%A1%A8%E7%99%BD%E5%A2%99%E6%94%BE%E5%85%A5%20webapp%20%E7%9B%AE%E5%BD%95.jpg)
         
      2. 约定前后端交互接口

         所谓“前后端交互接口” 是进行 Web 开发中的关键环节。
      
         具体来说，就是允许页面给服务器发送那些 HTTP 请求，并且每种请求采取什么样的格式。

         1. 获取全部留言

            请求：
            ```
            GET/message
            ```
            响应格式：
            ```
            {
               from: "黑猫",
               to: "白猫",
               message: "喵"
            }
            ```
            我们期望浏览器给服务器发送一个 GET/message 请求，就能返回当前一共有多少条留言记录，结果以 json 的格式返回。

         2. 发表新留言

            请求：body 也为 json 格式。
            ```
            POST /message

            {
            from: "黑猫",
            to: "白猫",
            message: "喵"
            }
            ```
            响应：json 格式
            ```
            ok: 1
            ```
            我们期望浏览器给服务器发送一个 POST/message 请求，就能够把当前的留言交给服务器。

      3. 实现服务器端代码

         ```
         class Message{
            public String from;
            public String to;
            public String message;
         }

         @WebServlet("/message")
         public class MessageWall extends HttpServlet {
            // 用于保存所有的留言
            private List<Message> messages = new ArrayList<Message>();
            // 用于转换 JSON 字符串
            private ObjectMapper objectMapper = new ObjectMapper();

            // 获取所有留言
            @Override
            protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
               resp.setContentType("application/json;charset=utf-8");
               String respString = objectMapper.writeValueAsString(messages);
               resp.getWriter().write(respString);
            }

            // 新增留言
            @Override
            protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
               resp.setContentType("application/json;charset=utf-8");
               Message message = objectMapper.readValue(req.getInputStream(), Message.class);
               messages.add(message);
               resp.getWriter().write("{\"ok\":：1}");
            }
         }
         ```
         * ObjectMpper 的 ReaderValue 方法也能直接把一个 InputStream 对象读取数据。
         * ObjectMapper 的 writeValueAsString 方法也能把一个对象数组直接转成 JSON 格式的字符串。
  
      4. 调整前端页面代码(修改“表白墙.html”)
   
         1. 拷贝之前封装好的 ajax 代码

            ```
            <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
            ```
         2. 新增加 load 函数，用于页面加载的时候获取数据

            ```
            // 1. 从服务器加载数据，显示在界面上
            function load(){
                  $.ajax({
                     url: "message",
                     method: "get",
                     contentType: "application/json;charset=utf-8",
                     success: function(data,status){
                        // data 是数据的 body，此时的响应可能是一个字符串格式，需要手动进行解析
                        let container = document.querySelector('.containner');
                        // let messages = JSON.parse(data);
                        let messages = data;
                        for(let message of messages){
                              let row = document.createElement('div');
                              row.className = 'row';
                              row.innerHTML = message.from + '对' + message.to + '谁' + message.message;
                              container.appendChild(row);
                        } 
                     }
                  });
            }
            // 调动 load 函数 执行数据加载
            load();
            ```
         3. 修改原来的点击事件回调函数. 在点击按钮的时候同时给服务器发送消息。

            ```
            // 2. 点击提交按钮的时候，把当前的数据构造成一个 HTTP 请求，发送给服务器
            let submitButton = document.querySelector('#submit');
            submitButton.onclick = function(){
                  // 1.先获取编辑框的消息
                  let edits = document.querySelectorAll('.edit');
                  let from = edits[0].value;
                  let to = edits[1].value;
                  let message = edits[2].value;
                  console.log(from + "对" + to + "说:" + message);
                  if(from == '' || to == '' || message == ''){
                     // 对用户的输入做一个简单的检验,验证一下当前是否是合法的提交
                     return;
                  }
                  // 2.根据内容,构造 HTML元素(.row 里面包含用户输入的话)
                  let row = document.createElement('div');
                  row.className = 'row';
                  row.innerHTML = from + "对" + to + "说:" + message;
                  // 3.把这个新的元素添加到 DOM 树上
                  let container = document.querySelector('.container');
                  container.appendChild(row);
                  // 4.清空原来的输入
                  for(let i = 0;i < edits.length;i ++){
                     edits[i].value = '';
                  }
                  // 5. 构造一个HTTP 请求，把消息发送给服务器保存
                  $.ajax({
                     url: "message",
                     method: "post",
                     data: JSON.stringify({from: from,to: to,message: message}),
                     contentType: "application/json;charset=utf-8",
                     success: function(data,status){
                        if(data.ok == 1){
                              console.log("提交消息成功! ");
                        }else{
                              console.log("提交消息失败！");
                        }
                     }
                  });
            }
            ```
            此时在浏览器通过 http://localhost:8080/day_05/表白墙.html 访问服务器，即可看到：

            ![表白墙](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E8%A1%A8%E7%99%BD%E5%A2%99.png)

            此时我们每次提交的数据都会发送给服务器. 每次打开页面的时候页面都会从服务器加载数据. 因此及时关闭页面, 数据也不会丢失。

            但是但是数据此时是存储在服务器的内存中 ( private List<Message> messages = new ArrayList<Message>(); ), 一旦服务器重启, 数据仍然会丢失。 
      
      5. 数据存入文件

         针对上面的问题，如果把数据保存在文件中，那么重启服务器就不会丢失数据了。

         修改 MessageServlet 代码。
            
            * 删除之前的 messages 成员。
            * 创建新的成员 String filePath，表示要存储的文件的路径。
            * 新增 load 方法，用来读取从文件中读取内容（会在页面加载的时候调用 load）。
            * 新增 sava() 方法，用来往文件中写入内容。(会在提交留言的时候调用 save())。
            * 文件格式按照 行文本 的方式存储，每个记录占一行，每个记录的字段之间（from to message ）用 \t 分隔。

         文件格式如下：

         ![数据存入文件格式显示](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E6%98%BE%E7%A4%BA.png)

         ```
         class Message{
            public String from;
            public String to;
            public String message;
         }

         @WebServlet("/message")
         public class MessageWall extends HttpServlet {

            // 用于转换 JSON 字符串
            private ObjectMapper objectMapper = new ObjectMapper();
            // 数据文件的路径
            private String filePath = "C:\\Users\\Administrator\\Desktop\\比特寒假班\\JAVA\\" +
                     "2022\\day_05\\src/messages.txt";


            // 获取所有留言
            @Override
            protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
               resp.setContentType("application/json;charset=utf-8");
               List<Message> messages = load();

               String respString = objectMapper.writeValueAsString(messages);
               resp.getWriter().write(respString);
            }


            private List<Message> load() {
               List<Message> messages = new ArrayList<Message>();
               System.out.println("从文件读取数据！");
               try (BufferedReader br = new BufferedReader(new
                        FileReader(filePath))) {
                     while (true) {
                        String line = br.readLine();
                        if (line == null) {
                           break;
                        }
                        String[] tokens = line.split("\t");
                        Message message = new Message();
                        message.from = tokens[0];
                        message.to = tokens[1];
                        message.message = tokens[2];
                        messages.add(message);
                     }
               } catch (IOException e) {
                     // 首次运行的时候文件不存在，可能会触发异常
                     e.printStackTrace();
               }
               System.out.println("共读取数据： " + messages.size() + "条");
               return messages;
            }

            // 新增留言
            @Override
            protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
               resp.setContentType("application/json;charset=utf-8");
               Message message = objectMapper.readValue(req.getInputStream(), Message.class);
               // messages.add(message);
               save(message);
               resp.getWriter().write("{\"ok\":：1}");
            }

            private void save(Message message) {
               System.out.println("向文件中写入数据！");
               // 使用追加的方式写入数据
               try (FileWriter fw = new FileWriter(filePath, true)) {
                     fw.write(message.from + "\t" + message.to + "\t" + message.message + "\n");
               }catch (IOException e){
                     e.printStackTrace();
               }
            }
         }
         ```
         此时即使重启服务器, 留言数据也不会丢失了。
      
      6. 数据存入数据库

         1. 在 pom.xml 中引入 mysql 的依赖

            ```
            <dependency>
                  <groupId>javax.servlet</groupId>
                  <artifactId>javax.servlet-api</artifactId>
                  <version>3.1.0</version>
            </dependency>
            ```
         2. 创建数据库，创建 messages 表
            ```
            show databases;

            create database if not exists MessageWall;

            use messagewall;

            drop table if exists messages;
            create table messages(
               `from`  varchar(2048),
               `to` varchar(2048),
               `message` varchar(4096)
            );
            ```
         3. 创建 DBUtil 类

            DBUtil 主要实现一下功能：
               * 创建 MysqlDataSource 实例，设置 URL，username，password 等属性。
               * 提供 getConnection 方法，和 MySQL 服务器建立连接。
               * 提供 close 方法，用来释放必要的资源。

            ```
            // 负责和数据库建立连接
            public class DBUtil {
               private static final String URL = "jdbc:mysql://127.0.0.1:3306/MessageWall?" +
                        "characterEncoding=utf8&useSSL=false";
               private static final String USERNAME = "root";
               private static final String PASSWORD ="0412";

               private static DataSource dataSource = null;

               public static DataSource getDataSource() {
                  if(dataSource == null){
                        synchronized (DBUtil.class) {
                           if(dataSource == null){
                              dataSource = new MysqlDataSource();
                              ((MysqlDataSource)dataSource).setUrl(URL);
                              ((MysqlDataSource)dataSource).setUser(USERNAME);
                              ((MysqlDataSource)dataSource).setPassword(PASSWORD);
                           }
                        }
                  }
                  return dataSource;
               }

               public static Connection getConnection(){
                  try {
                        return getDataSource().getConnection();
                  } catch (SQLException throwables) {
                        throwables.printStackTrace();
                  }
                  return null;
               }

               public static void close(Connection connection,
                                       PreparedStatement statement, ResultSet resultSet){
                  try {
                        if(resultSet != null){
                           resultSet.close();
                        }
                  } catch (SQLException throwables) {
                        throwables.printStackTrace();
                  }

                  try {
                        if(statement != null){
                           statement.close();
                        }
                  } catch (SQLException throwables) {
                        throwables.printStackTrace();
                  }

                  try {
                        if(connection != null){
                           connection.close();
                        }
                  } catch (SQLException throwables) {
                        throwables.printStackTrace();
                  }
               }
            }
            ```
         4. 修改 load 和 save 方法, 改成操作数据库

            ```
            @WebServlet("/messagewall")
            public class MessageWallServlet extends HttpServlet {
               // 用于转换 JSON 字符串
               private ObjectMapper objectMapper = new ObjectMapper();

               // 获取所有留言


               @Override
               protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
                  resp.setContentType("application/json;charset=utf-8");

                  List<Message> messages = load();
                  String respString = objectMapper.writeValueAsString(messages);
                  resp.getWriter().write(respString);

               }

               private List<Message> load() {
                  List<Message> messages = new ArrayList<>();

                  Connection connection = null;
                  PreparedStatement statement = null;
                  ResultSet resultSet = null;

                  try {
                        // 1. 和数据库建立连接
                        connection = DBUtil.getConnection();
                        // 2. 拼装 SQL
                        String sql = "select * from messages";
                        statement = connection.prepareStatement(sql);
                        // 3. 执行 SQL
                        resultSet = statement.executeQuery();
                        // 4. 遍历结果集合
                        while(resultSet.next()){
                           Message message = new Message();
                           message.from = resultSet.getString("from");
                           message.to = resultSet.getString("to");
                           message.message = resultSet.getString("message");
                           messages.add(message);
                        }
                  } catch (SQLException throwables) {
                        throwables.printStackTrace();
                  } finally {
                        //  5. 释放必要的资源
                        DBUtil.close(connection,statement,resultSet);
                  }
                  return messages;
               }

               @Override
               protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
                  resp.setContentType("application/json;charset=utf-8");
                  Message message = objectMapper.readValue(req.getInputStream(), Message.class);

                  save(message);
                  resp.getWriter().write("{\"ok\":：1}");
               }

               private void save(Message message) {
                  Connection connection = null;
                  PreparedStatement statement = null;
                  try {
                        // 1. 和数据库建立连接
                        connection = DBUtil .getConnection();
                        // 2. 拼装 SQL
                        String sql = "insert into messages values(?,?,?)";
                        statement = connection.prepareStatement(sql);
                        statement.setString(1,message.from);
                        statement.setString(2,message.to);
                        statement.setString(3,message.message);
                        // 3. 执行 SQL
                        int ret = statement.executeUpdate();

                        if(ret == 1){
                           System.out.println("插入成功！");
                        }else{
                           System.out.println("插入失败！");
                        }
                  } catch (SQLException throwables) {
                        throwables.printStackTrace();
                  } finally {
                        // 4. 释放必要的资源
                        DBUtil.close(connection,statement,null);
                  }
               }
            }
            ```
            重新部署程序，也会发现数据不再丢失！
      
      7. 思考：为什么我们说 "使用文件" 不优雅, "使用数据库" 更科学 呢?

         当前看起来, 明显是数据库操作的代码量要比文件操作的代码量更多呀.但是实际上, 当前我们写的程序比较简单, 存储的数据比较少, 数据格式也不复杂. 这种情况下使用文件是比数据库代码更精简一些.。

         但是如果我们的程序更复杂, 数据更多并且数据格式也更复杂的时候, 单纯的文件操作就要比数据库操作更麻烦了。

         因为数据库已经给我们提供了很多功能可以开箱即用. (例如数据类型的校验, 约束, 聚合查询, 联合查询, 子查询, 索引, 事务等等). 而如果基于文件来完成类似的功能, 就需要我们自己写很多代码来手动实现了。
   
3. web 开发的“编程思维”
   
   1. 明确需求
   2. 约定好前后端交互的接口
   3. 实现服务器端的代码（涉及到一些存储数据的操作，需要使用 Mysql 或者 存储文件）
   4. 实现客户端的代码（HTML,CSS,JS,ajax）

# 七、Cookie 和 Session

## 1、回顾 Cookie 

&emsp;Cookie 是 HTTP 协议中的一个字段，同时也是浏览器在客户端保存数据的一种比较古老的方式。

&emsp;Cookie 的理解：
1. Cookie 从哪里来？**服务器产生的**，通过HTTP响应的 set-Cookie 字段进行设置，返回给浏览器。
2. Cookie 怎么存？在浏览器中存储，浏览器会根据域名/地址，来分别存储 Cookie。
3. Cookie 到哪里去？会在下次请求中自定添加到请求中，发送给服务器。
4. Cookie 存的内容？**键值对结构的字符串**。此处的键值对都是程序员自定义的。

   ![Cookie 登录过程](https://raw.githubusercontent.com/yimu-0412/image/master/image/Cookie%20%E7%99%BB%E5%BD%95%E8%BF%87%E7%A8%8B.jpg)

   图中的 "令牌" 通常就存储在 Cookie 字段中。    

## 2、理解会话机制

&emsp;&emsp;Session 叫做“回话”。

&emsp;&emsp;Http 协议本身是无状态的。"无状态" 的含义指的是:默认情况下 HTTP 协议的客户端和服务器之间的这次通信, 和下次通信之间没有直接的联系。

&emsp;&emsp;某个 用户A 对服务器发送了两次请求，第一次请求和第二次请求，对于服务器来说，是感知不到关联关系的。

&emsp;&emsp;实际开发中，需要有关联状态，用户登录完成之后，后续在访问这个网站的时候，就可可以知道这个用户的身份信息。

&emsp;&emsp;Session 是**在服务器端存储的**，可以把 Session 想象成一个 hash 表，key 就是 sessionId，value 就是程序员自定义的数据。

&emsp;&emsp;Cookie 和 Session 是要相互配合的。

   ![Cookie和Session的配合使用](https://raw.githubusercontent.com/yimu-0412/image/master/image/Cookie%E5%92%8CSession%E7%9A%84%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8.png)

&emsp;&emsp;在上面这个场景中，服务器返回的 Set-Cookie 中，一定要放 sessionId 吗？如果直接把用户的信息序列化一下，听过 Set-Cookie 返回给浏览器，是否可行？

&emsp;&emsp;其实也是可以的，只要能够让两个请求被联系起来就行！进行联系的不一定非得是 sessionId，也可以是 userId，也可以是其他的 id···

&emsp;&emsp;使用 sessionId 只是一种常见的做法！这样做的好处是，可以方便实现“注销操作”。

&emsp;&emsp;注销操作：在服务器这边把 session 哈希表中对应的键值对删了即可，返回 sessionId 也有助于保护用户的隐私。

&emsp;&emsp;当前此处所说 cookie 和 session 的联动，主要是针对主流的网页的实现。如果是更新一些的网页，实现的时候不完全依赖 cookie，cokie 存在的目的就是为了在浏览器进行本地存储。还可以使用 localStorage 或者 indexDB 来代替 Cookie。

## 3、Cookie 和 Session 的区别

1. Cookie 是客户端的机制，Session 是服务器端的机制。
2. Cookie 和 Session 经常会在一起配合使用，但是不是必须配合。
   
   * 完全可以使用 Cookie 来保存一些数据再客户端，这些数据不一定是用户身份信息，也不一定是 token/sessionId。
   * Session 中 token/sessionId 也不需要非得通过 Cookie/Set-Cookie 传递。

## 4、核心方法

1. HttpServletRequest 类中的相关方法

   ![HttpServletRequest类中相关方法](https://raw.githubusercontent.com/yimu-0412/image/master/image/HttpServletRequest%E7%B1%BB%E4%B8%AD%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95.png)

   * ``HttpSession getSession()``最常用的方法。功能有两个：
      
      * 尝试根据当前请求中的 sessionId 获取当前的 session：1. 如果 session 不存在，就进行创建；2. 如果存在，就返回。
      * sessionId 是从 Cookie 来的，**如果当前的 sessionId 在 hash 表中不存在，就会创建会话。创建 HttpSession 对象，作为 value；创建 sessionId（随机的字符串）作为 key，然后将这个 key 和 value 插入到 hash 表中。同时把这个 sessionId 返回给浏览器。**
      * **HttpSession 存储的是键值对结构**，里面的 key 和 value 是程序员自定义的。
   * Cookie 中有两个主要的属性：key 和 value。

2. HttpServletResponse 类中的相关方法

   ![HttpServletResponse 类中的相关方法](https://raw.githubusercontent.com/yimu-0412/image/master/image/HttpServletResponse%20%E7%B1%BB%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95.png)

3. HttpSession 类中的相关方法

   一个 HttpSession 对象里面包含多个键值对. 我们可以往 HttpSession 中存任何我们需要的信息。

   ![HttpSession 类中的相关方法](https://raw.githubusercontent.com/yimu-0412/image/master/image/HttpSession%20%E7%B1%BB%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95.png)

4. Cookie 类中的相关方法

   ![Cookie 类中的相关方法](https://raw.githubusercontent.com/yimu-0412/image/master/image/Cookie%20%E7%B1%BB%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95.png)

   * HTTP 的 Cooke 字段中存储的实际上是多组键值对. 每个键值对在 Servlet 中都对应了一个 Cookie 对象。
   * 通过 **HttpServletRequest.getCookies()** 获取到请求中的一系列 Cookie 键值对。
   * 通过 **HttpServletResponse.addCookie()** 可以向响应中添加新的 Cookie 键值对。
  
## 5、代码示例：实现用户登录

&emsp;&emsp;实现简单的用户登录逻辑。

&emsp;&emsp;主要是通过 HttpSession 类完成. 并不需要我们手动操作 Cookie 对象。

1. 创建 IndexServlet 类

   ```
   @WebServlet("/index")
   public class IndexServlet extends HttpServlet {
      @Override
      protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
         resp.setContentType("test/html;charset=utf-8");
         // 1. 判断当前用户是否登录
         HttpSession session = req.getSession(false);
         if(session == null){
               // 用户没有登录重定向到 login.html
               resp.sendRedirect("login.html");
               return;
         }
         // 2. 如果已经登录，则从 Session 中取出访问次数数据
         String username = (String) session.getAttribute("username");
         String countString = (String) session.getAttribute("loginCount");
         int loginCount = Integer.parseInt(countString);
         loginCount += 1;
         session.setAttribute("loginCount",loginCount + "");

         // 3. 展示到页面上
         StringBuilder html = new StringBuilder();
         html.append(String.format("<div>用户名： %s</div>",username));
         html.append(String.format("<div>loginCount: %d</div>",loginCount));
         resp.getWriter().write(html.toString());

      }
   }
   ```
   * 这个代码中是看不到“哈希表”，也看不到 sessionId 这样的概念。getSession 操作内部提取到请求中的 Cookie 里的 sessionId，然后查找哈希表，获取当前对应的 HttpSession 对象。
   * getSession 参数为 false, 则获取不到 HttpSession 对象, 不会创建新的 HttpSession, 而是返回null. 此时说明用户没有登陆。

2. 创建 login.html ，放到 webapp 目录中

   ```
   <form action="login" method="POST">
      <input type="text" name="username">
      <br>
      <input type="password" name="password">
      <br>
      <input type="submit" value="提交">
   </form>
   ```
3. 创建 LoginServlet 类

   ```
   @WebServlet("/login")
   public class LoginServlet extends HttpServlet {
      @Override
      protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
         resp.setContentType("text/html;charset=utf-8");
         // 1. 获取用户提交的用户名和密码
         String username = req.getParameter("username");
         String password = req.getParameter("password");
         // 2.判定用户名是否正确
         if(!username.equals("yimu") || !password.equals("123")){
               resp.getWriter().write("登录失败！");
               return;
         }
         // 登陆成功
         System.out.println("登陆成功!");
         // 设置 Session
         HttpSession session = req.getSession(true);
         session.setAttribute("username","yimu");
         session.setAttribute("loginCount","0");
         resp.sendRedirect("index");
      }
   }
   ```
   * 此处的 getSession 参数为 true, 表示查找不到 HttpSession 时会创建新的 HttpSession 对象, 并生成一个 sessionId, 插入到 哈希表 中, 并且把 sessionId 通过 Set-Cookie 返回给浏览器。

4. 部署程序，通过 http://localhost:8080/day_05/index 访问，
   * 首次访问的时候可以看到, 当前用户尚未登陆, 此时页面自动重定向到 login.html

      ```
      HTTP/1.1 302
      Location: login.html
      Content-Type: test/html;charset=utf-8
      Content-Length: 0
      Date: Fri, 11 Feb 2022 03:01:07 GMT
      Keep-Alive: timeout=20
      Connection: keep-alive
      ```
      首次访问 /index 的时候会返回 重定向 报文.
   
   * 在 login.html 中输入用户名密码之后, 会跳转到 /login 路径. 此时服务器返回了一个 token, 并在 Session 中记录用户信息, 然后重定向到 /index

      ```
      HTTP/1.1 302
      Set-Cookie: JSESSIONID=3653C118D3AA5F2EB8BD63359448544E; Path=/day_05; HttpOnly
      Location: index
      Content-Type: text/html;charset=utf-8
      Content-Length: 0
      Date: Fri, 11 Feb 2022 03:02:04 GMT
      Keep-Alive: timeout=20
      Connection: keep-alive
      ```
      **注意:** 响应中的 302, Location, Set-Cookie 字段. 其中 1CBA3519A24801120ADC3C00A70FF047 即为 Servlet 自动生成的 token。
   * 在 /index 中, 通过 Session 拿到了用户信息, 进一步获取到用户的访问次数。

# 八、上传文件

## 1、核心方法
   1. HttpServletRequest 类方法

      ![上传文件核心方法1](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%951.png)

   2. Part 类方法

      ![Part 类方法](https://raw.githubusercontent.com/yimu-0412/image/master/image/Part%20%E7%B1%BB%E6%96%B9%E6%B3%95.png)

## 2、代码示例

&emsp;&emsp;实现将一个图片上传到服务器。

1. 创建 upload.html，放到 webapp 目录中

   ```
   <form action="upload" enctype="multipart/form-data" method="POST">
      <input type="file" name="MyImage">
      <input type="submit" value="提交图片">
   </form>
   ```
   * 上传文件一般通过 POST 请求的表单实现。
   * 在 form 中要加上 multipart/form-data 字段。
  
2. 创建 UploadServlet 类

   ```
   @MultipartConfig
   @WebServlet("/upload")
   public class UploadServlet extends HttpServlet {

      @Override
      protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
         String path = getServletContext().getRealPath("/image");
         Part part = req.getPart("myImage");
         System.out.println(part.getSubmittedFileName());
         System.out.println(part.getContentType());
         System.out.println(part.getSize());
         part.write(path +"/" + part.getSubmittedFileName());
         resp.getWriter().write("upload ok!");
      }
   }
   ```
   * 需要给 UploadServlet 加上 @MultipartConfig 注解. 否则服务器代码无法使用 getPart 方法。
   * getPart 的 参数 需要和 form 中 input 标签的 name 属性对应。
   * 客户端一次可以提交多个文件. (使用多个 input 标签). 此时服务器可以通过 getParts 获取所有的 Part 对象。

3. 部署程序，在浏览器通过 http://localhost:8080/day_05/upload.html 访问。

   ![上传文件](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6.png)

   选择文件后, 点击提交图片, 则页面跳转到 /upload 页面。

   ![上传文件成功](https://raw.githubusercontent.com/yimu-0412/image/master/image/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%88%90%E5%8A%9F.png)

   上传图片请求的抓包结果为：

   ```
   POST http://localhost:8080/day_05/upload HTTP/1.1
   Host: localhost:8080
   Connection: keep-alive
   Content-Length: 3497142
   Cache-Control: max-age=0
   sec-ch-ua: " Not A;Brand";v="99", "Chromium";v="98", "Microsoft Edge";v="98"
   sec-ch-ua-mobile: ?0
   sec-ch-ua-platform: "Windows"
   Upgrade-Insecure-Requests: 1
   Origin: http://localhost:8080
   Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryphe00oRzvnFTOlb5
   User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.80 Safari/537.36 Edg/98.0.1108.43
   Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
   Sec-Fetch-Site: same-origin
   Sec-Fetch-Mode: navigate
   Sec-Fetch-User: ?1
   Sec-Fetch-Dest: document
   Referer: http://localhost:8080/day_05/upload.html
   Accept-Encoding: gzip, deflate, br
   Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6
   Cookie: JSESSIONID=756F33AD6A837C145B930DD4E216A62D; Idea-8296e76f=b5903ad5-c679-4771-a266-5c2da89d50d7

   ------WebKitFormBoundaryphe00oRzvnFTOlb5
   Content-Disposition: form-data; name="myImage"; filename="02.jpg"
   Content-Type: image/jpeg
   ```
   可以看到：Content-Type: multipart/form-data;这个请求中带有一个 boundary=----WebKitFormBoundaryphe00oRzvnFTOlb5，这个 boundary 在 body 这边作为一个 "分隔线", 分隔线下面是上传的文件的属性和文件内容。